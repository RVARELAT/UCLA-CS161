##############
# Homework 3 #
##############


###################
# Read This First #
###################


# All functions that you need to modify are marked with 'EXERCISE' in their header comments.
# Do not modify astar.py
# This file also contains many helper functions. You may call any of them in your functions.


# Due to the memory limitation, the A* algorithm may crash on some hard sokoban problems if too many
# nodes are generated. Improving the quality of the heuristic will mitigate
# this problem, as it will allow A* to solve hard problems with fewer node expansions.


# Remember that most functions are not graded on efficiency (only correctness).
# Efficiency can only influence your heuristic performance in the competition (which will affect your score).


# Load the astar.py and do not modify it.
import astar
# Load the numpy package and the state is represented as a numpy array during this homework.
import numpy as np


# a_star perform the A* algorithm with the start_state (numpy array), goal_test (function), successors (function) and
# heuristic (function). a_star prints the solution from start_state to goal_state (path), calculates the number of
# generated nodes (node_generated) and expanded nodes (node_expanded), and the solution depth (len(path)-1). a_star
# also provides the following functions for printing states and moves: prettyMoves(path): Translate the solution to a
# list of moves printlists(path): Visualize the solution and Print a list of states
def a_star(start_state, goal_test, successors, heuristic):
    goal_node, node_generated, node_expanded = astar.a_star_search(start_state, goal_test, successors, heuristic)
    if goal_node:
        node = goal_node
        path = [node.state1]
        while node.parent:
            node = node.parent
            path.append(node.state1)
        path.reverse()

        # print('My path:{}'.format(path))
        # print(prettyMoves(path))
        # printlists(path)
        print('Nodes Generated by A*: {}'.format(node_generated))
        print('Nodes Expanded by A*: {}'.format(node_expanded))
        print('Solution Depth: {}'.format(len(path) - 1))
    else:
        print('no solution found')


# A shortcut function
# Transform the input state to numpy array. For other functions, the state s is presented as a numpy array.
# Goal-test and next-states stay the same throughout the assignment
# You can just call sokoban(init-state, heuristic function) to test the result
def sokoban(s, h):
    return a_star(np.array(s), goal_test, next_states, h)


# Define some global variables
blank = 0
wall = 1
box = 2
keeper = 3
star = 4
boxstar = 5
keeperstar = 6


# Some helper functions for checking the content of a square
def isBlank(v):
    return (v == blank)


def isWall(v):
    return (v == wall)


def isBox(v):
    return (v == box)


def isKeeper(v):
    return (v == keeper)


def isStar(v):
    return (v == star)


def isBoxstar(v):
    return (v == boxstar)


def isKeeperstar(v):
    return (v == keeperstar)


# Help function for get KeeperPosition
# Given state s (numpy array), return the position of the keeper by row, col
# The top row is the zeroth row
# The first (right) column is the zeroth column
def getKeeperPosition(s):
    row = s.shape[0]
    col = s.shape[1]
    for i in range(row):
        for j in range(col):
            if (isKeeper(s[i, j]) or isKeeperstar(s[i, j])):
                return i, j


# For input list s_list, remove all None element
# For example, if s_list = [1, 2, None, 3], returns [1, 2, 3]
def cleanUpList(s_list):
    clean = []
    for state in s_list:
        if state is not None:
            clean.append(state)
    return clean


# EXERCISE: Modify this function to return True
# if and only if s (numpy array) is a goal state of a Sokoban game.
# (no box is on a non-goal square)
# Remember, the number of goals can be larger than the number of box. It returns True if there are no boxes left that are not on goals and False otherwise.
def goal_test(s):
    # Solution: This function checks whether all boxes are on goal positions. It returns True if there are no boxes left that are not on goals and False otherwise.
    
    # '2' means a box is not on a goal, So we return false, else we can return true (s == 2 coverts numpy array to a True and False grid, np.any checks if we have a true in our grid)
    if (np.any(s == 2) == True):
        return False
    else:
        return True
    
    
######### Helpers for next_states function ###########################

# A function called get_square that takes in a state S, a row number r and a column number c. It returns the integer content of state S at square (r, c). If the square is outside the scope of the problem, return the value of a wall.
def get_square(S, r, c):
    # Solution: This helper function safely retrieves the value at a specfic (row, column) position in the state. If the coords are out of bounds, it returns 1 (which represents a wall) to prevent invalid access.
    
    # get the number of rows
    number_of_rows = S.shape[0]
    # get the number of columns
    number_of_columns = S.shape[1]
    
    # check that row is in bounds
    if r < 0 or r >= number_of_rows:
        # '1' represents a wall
        return 1
    # check that column is in bounds
    if c < 0 or c >= number_of_columns:
        # '1' represents a wall
        return 1
    
    # else we can return what we have at the [r,c] position
    return S[r, c]

# A function called set_square that takes in a state S, a row number r, a column number c and a square content v (integer). This function returns a new state S′ that is obtained by setting the square (r, c) to value v. This function should not modify the input state.
def set_square(S, r, c, v):
    # Solution: This helper function returns a modified copy of the input state by updating the value at a specific (row, column) location. It ensures the original state is not changed by making a deep copy before applying the update.
    
    # we don't want to change the original state so we make a copy
    new_S = np.copy(S)
    # change (r,c) to value v
    new_S[r,c] = v
    # returns a new state
    return new_S

# Write a function try_move that takes in a state S and a move direction D. This function should return the state that is the result of moving the keeper in state S in direction D. None should be returned if the move is invalid (e.g. there is a wall in that direction). How you represent a move direction is up to you. Remember to update the content of every square to the right value. Refer to Table 1 for the values of different types of square.
def try_move(S, D):
    # Solution: This function attempts to move the keeper in the given direction. It checks if the move is valid (e.g., into an empty space, goal, or by pushing a box), and returns a new state reflecting the updated positions. Note it carefully updates the board using set_square to avoid modifying the original state.
    
    # unwrap the move direction 
    direction_desired_r, direction_desired_c = D
    # find the keeper position
    keeper_r, keeper_c = getKeeperPosition(S)
    # calculate where the keeper wants to move
    direction_to_move_r = direction_desired_r + keeper_r
    direction_to_move_c = direction_desired_c + keeper_c
    # Check a space ahead of where we are moving, we can do this by just doubling their movement (useful for checking if there is a box)
    step_ahead_direction_to_move_r = (direction_desired_r * 2) + keeper_r
    step_ahead_direction_to_move_c = (direction_desired_c * 2) + keeper_c
    
    # get the square symbol of the direction to move
    square_of_direction_to_move = get_square(S, direction_to_move_r, direction_to_move_c)
    
    # if the direction we want to move is empty we simply move to that position
    if (square_of_direction_to_move == 0):
        # change keepers old spot (if keeper was on top of the goal we want to keep the goal)
        if (get_square(S, keeper_r, keeper_c) == 6):
            new_S = set_square(S, keeper_r, keeper_c, 4)
        # simply set the old spot to an empty spot
        else:
            new_S = set_square(S, keeper_r, keeper_c, 0)
        # now we can set the new spot
        new_S = set_square(new_S, direction_to_move_r, direction_to_move_c, 3)
        return new_S
    
    # if the direction we want to move is a goal
    if (square_of_direction_to_move == 4):
        # chage keepers old spot
        new_S = set_square(S, keeper_r, keeper_c, 0)
        # update the new spot to keeper + goal
        new_S = set_square(new_S, direction_to_move_r, direction_to_move_c, 6)
        return new_S
        
    # if the direction to move requires pushing a box
    if (square_of_direction_to_move == 2 or square_of_direction_to_move == 5):
        # make sure the space after the box is empty
        if (get_square(S, step_ahead_direction_to_move_r, step_ahead_direction_to_move_c) == 0):
            # change keepers old spot 
            # check if keeper was on top of a goal
            if (get_square(S, keeper_r, keeper_c) == 6):
                new_S = set_square(S, keeper_r, keeper_c, 4)
            else:
                new_S = set_square(S, keeper_r, keeper_c, 0)
            # set new spot of keeper
            # check if box was on top of the goal
            if (square_of_direction_to_move == 5):
                # set the new keeper spot to keeper + goal
                new_S = set_square(new_S, direction_to_move_r, direction_to_move_c, 6)
            else:  
                new_S = set_square(new_S, direction_to_move_r, direction_to_move_c, 3)
            # set new spot after the box being pushed to a box
            new_S = set_square(new_S, step_ahead_direction_to_move_r, step_ahead_direction_to_move_c, 2)
            return new_S
                
        # make sure the space after the box is a goal
        if (get_square(S, step_ahead_direction_to_move_r, step_ahead_direction_to_move_c) == 4):
            # change keepers old spot 
            new_S = set_square(S, keeper_r, keeper_c, 0)
            # set new spot of keeper
            new_S = set_square(new_S, direction_to_move_r, direction_to_move_c, 3)
            # set new spot after the box being pushed to a box + goal
            new_S = set_square(new_S, step_ahead_direction_to_move_r, step_ahead_direction_to_move_c, 5)
            return new_S
                    
    # Move is not allowed (we have a wall or a blocked box)
    return None

################ end of helpers ####################################

# EXERCISE: Modify this function to return the list of
# successor states of s (numpy array).
#
# This is the top-level next-states (successor) function.
# Some skeleton code is provided below.
# You may delete them totally, depending on your approach.
# 
# If you want to use it, you will need to set 'result' to be 
# the set of states after moving the keeper in each of the 4 directions.
#
# You can define the function try-move and decide how to represent UP,DOWN,LEFT,RIGHT.
# Any None result in the list can be removed by cleanUpList.
#
# When generated the successors states, you may need to copy the current state s (numpy array).
# A shallow copy (e.g, direcly set s1 = s) constructs a new compound object and then inserts references 
# into it to the objects found in the original. In this case, any change in the numpy array s1 will also affect
# the original array s. Thus, you may need a deep copy (e.g, s1 = np.copy(s)) to construct an indepedent array.
def next_states(s):
    # Solution: check every movement using our try_move function and append it to our our list of states if it is valid (not none).
    
    # note the deep copy is handled by my try_move function
    s_list = []
    
    # check movement up
    move_up = try_move(s, (-1,0))
    if move_up is not None:
        s_list.append(move_up)
        
    # check movement down
    move_down = try_move(s, (1,0))
    if move_down is not None:
        s_list.append(move_down)
    
    # check movement left
    move_left = try_move(s, (0,-1)) 
    if move_left is not None:
        s_list.append(move_left)
    
    # check movement right
    move_right = try_move(s, (0,1))
    if move_right is not None:
        s_list.append(move_right)
    
    return cleanUpList(s_list)


# EXERCISE: Modify this function to compute the trivial
# admissible heuristic. The argument is the state and this is a simple heuristic that always returns 0.
def h0(s):
    # Solution: This is a simple heuristic that always returns 0. It is safe to use in A* because it never guesses too high. But it doesn't help the search — it treats every state like it's the same distance from the goal.
    return 0 

# EXERCISE: Modify this function to compute the
# number of misplaced boxes in state s (numpy array). Return misplaced box count.
def h1(s):
    # Solution: This heuristic counts how many boxes are not on goal positions (value 2). The more misplaced boxes there are, the farther we are from the goal. It’s a simple and safe guess — it never overestimates.
    
    # np.sum counts how many True values there are on our numpy array (A true value is if a box is in that position aka if its the number '2')
    misplaced_box_count = np.sum(s == 2)
    return misplaced_box_count
    

# EXERCISE: Is this heuristic admissible? Return true if yes, false if no. Explain your reasoning
# as comments in this function.
def h1_admissible():
    # Solution: h1 counts how many boxes are not on goal positions. Each of those boxes will need at least one push to reach a goal, so h1 never guesses too high. That means it's a safe (admissible) heuristic. It might guess too low sometimes, but that's okay — as long as it's never too much. SO I return True.
    return True


######################### Helper for h2 #########################

# this helper function takes a list of items you want to find all permutations of and retuns a lists of lists which is a list containing all possible orderings (permutations) of the input list.
def make_permutations(lst):
    # Solution: builds up the permutations one item at a time, by inserting each new item into every possible position of the existing partial permutations.
    
    # empty list for permuatations
    permutations_list = [[]]
    for item in lst:
        new_result = []
        for permuation in permutations_list:
            # Try inserting the current item into every possible position in permutation
            for i in range (1 + len(permuation)):
                # insert at index i
                new_permutation = permuation[:i] + [item] + permuation[i:]
                new_result.append(new_permutation)
        # add new permutations made to list of permuatations
        permutations_list = new_result
    return permutations_list
    

# EXERCISE: 
# This function will be tested in various hard examples.
# Objective: make A* solve problems as fast as possible.
# This heuristic function takes in a state and returns an integer (≥ 0).
def h2(s):
    # Solution: This heuristic tries every way to match boxes to goals and picks the one with the least total distance. This heuristic is admissible because it never guesses too high. It just adds up the shortest straight-line paths from boxes to goals, without thinking about walls, so the real steps will always be the same or more.
    
    # get all box and goal positions
    box_positions = []
    goal_positions = []

    # loop over rows
    for i in range(s.shape[0]):
        # loop over columns
        for j in range(s.shape[1]):
            # box not on goal
            if s[i, j] == 2:
                box_positions.append((i, j))
            # goal-related tiles (aka: goal or box + goal or keeper + goal)
            elif s[i, j] in (4, 5, 6):
                goal_positions.append((i, j))
                
    # check if any of the boxes is stuck in a corner and not on a goal
    # note: a box that is stuck in a corner, is not solvable
    for r,c in box_positions:
        # don't check out of bounds 
        if r > 0 and c > 0 and r < s.shape[0] - 1 and c < s.shape[1] - 1:
            # ignore boxes already on a goal (box + goal = 5)
            if s[r, c] == 5:
                continue
            # If top or bottom is a wall
            if (s[r - 1, c] == 1 or s[r + 1, c] == 1):
                # And left or right is a wall 
                if (s[r, c - 1] == 1 or s[r, c + 1] == 1):
                # Then the box is in a corner so return an infinite number
                    return 10**6 

    # set it to infinity since we are sure will find a smaller total distance
    minimum_total_distance = float('inf')
    # get all possible ways to arrange the goal positions
    all_matchings = make_permutations(goal_positions)

    for matching in all_matchings:
        # total distance for box and goal matching
        total = 0
        # we now go through each box and the goal it's assigned
        for i in range (len(box_positions)):
            box_r, box_c = box_positions[i]
            goal_r, goal_c = matching[i]
            # solve Manhattan distance
            distance = abs(box_r - goal_r) + abs(box_c - goal_c)
            # Add this distance to the total
            total += distance

        # If this total is smaller than what we've seen, update it
        if total < minimum_total_distance:
            minimum_total_distance = total

    return minimum_total_distance

    

# Some predefined problems with initial state s (array). Sokoban function will automatically transform it to numpy
# array. For other function, the state s is presented as a numpy array. You can just call sokoban(init-state,
# heuristic function) to test the result Each problem can be visualized by calling prettyMoves(path) and printlists(
# path) in a_star function
#
# Problems are roughly ordered by their difficulties.
# For most problems, we also provide 2 additional number per problem:
#    1) # of nodes expanded by A* using our next-states and h0 heuristic.
#    2) the depth of the optimal solution.
# These numbers are located at the comments of the problems. For example, the first problem below 
# was solved by 80 nodes expansion of A* and its optimal solution depth is 7.
# 
# Your implementation may not result in the same number of nodes expanded, but it should probably
# give something in the same ballpark. As for the solution depth, any admissible heuristic must 
# make A* return an optimal solution. So, the depths of the optimal solutions provided could be used
# for checking whether your heuristic is admissible.
#
# Warning: some problems toward the end are quite hard and could be impossible to solve without a good heuristic!


# [80,7]
s1 = [[1, 1, 1, 1, 1, 1],
      [1, 0, 3, 0, 0, 1],
      [1, 0, 2, 0, 0, 1],
      [1, 1, 0, 1, 1, 1],
      [1, 0, 0, 0, 0, 1],
      [1, 0, 0, 0, 4, 1],
      [1, 1, 1, 1, 1, 1]]

# [110,10],
s2 = [[1, 1, 1, 1, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 1],
      [1, 0, 0, 0, 0, 0, 1],
      [1, 0, 0, 2, 1, 4, 1],
      [1, 3, 0, 0, 1, 0, 1],
      [1, 1, 1, 1, 1, 1, 1]]

# [211,12],
s3 = [[1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 0, 0, 0, 1, 0, 0, 0, 1],
      [1, 0, 0, 0, 2, 0, 3, 4, 1],
      [1, 0, 0, 0, 1, 0, 0, 0, 1],
      [1, 0, 0, 0, 1, 0, 0, 0, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1]]

# [300,13],
s4 = [[1, 1, 1, 1, 1, 1, 1],
      [0, 0, 0, 0, 0, 1, 4],
      [0, 0, 0, 0, 0, 0, 0],
      [0, 0, 1, 1, 1, 0, 0],
      [0, 0, 1, 0, 0, 0, 0],
      [0, 2, 1, 0, 0, 0, 0],
      [0, 3, 1, 0, 0, 0, 0]]

# [551,10],
s5 = [[1, 1, 1, 1, 1, 1],
      [1, 1, 0, 0, 1, 1],
      [1, 0, 0, 0, 0, 1],
      [1, 4, 2, 2, 4, 1],
      [1, 0, 0, 0, 0, 1],
      [1, 1, 3, 1, 1, 1],
      [1, 1, 1, 1, 1, 1]]

# [722,12],
s6 = [[1, 1, 1, 1, 1, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 4, 1],
      [1, 0, 0, 0, 2, 2, 3, 1],
      [1, 0, 0, 1, 0, 0, 4, 1],
      [1, 1, 1, 1, 1, 1, 1, 1]]

# [1738,50],
s7 = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
      [0, 0, 1, 1, 1, 1, 0, 0, 0, 3],
      [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
      [0, 0, 0, 0, 0, 1, 0, 0, 1, 0],
      [0, 0, 1, 0, 0, 1, 0, 0, 1, 0],
      [0, 2, 1, 0, 0, 0, 0, 0, 1, 0],
      [0, 0, 1, 0, 0, 0, 0, 0, 1, 4]]

# [1763,22],
s8 = [[1, 1, 1, 1, 1, 1],
      [1, 4, 0, 0, 4, 1],
      [1, 0, 2, 2, 0, 1],
      [1, 2, 0, 1, 0, 1],
      [1, 3, 0, 0, 4, 1],
      [1, 1, 1, 1, 1, 1]]

# [1806,41],
s9 = [[1, 1, 1, 1, 1, 1, 1, 1, 1],
      [1, 1, 1, 0, 0, 1, 1, 1, 1],
      [1, 0, 0, 0, 0, 0, 2, 0, 1],
      [1, 0, 1, 0, 0, 1, 2, 0, 1],
      [1, 0, 4, 0, 4, 1, 3, 0, 1],
      [1, 1, 1, 1, 1, 1, 1, 1, 1]]

# [10082,51],
s10 = [[1, 1, 1, 1, 1, 0, 0],
       [1, 0, 0, 0, 1, 1, 0],
       [1, 3, 2, 0, 0, 1, 1],
       [1, 1, 0, 2, 0, 0, 1],
       [0, 1, 1, 0, 2, 0, 1],
       [0, 0, 1, 1, 0, 0, 1],
       [0, 0, 0, 1, 1, 4, 1],
       [0, 0, 0, 0, 1, 4, 1],
       [0, 0, 0, 0, 1, 4, 1],
       [0, 0, 0, 0, 1, 1, 1]]

# [16517,48],
s11 = [[1, 1, 1, 1, 1, 1, 1],
       [1, 4, 0, 0, 0, 4, 1],
       [1, 0, 2, 2, 1, 0, 1],
       [1, 0, 2, 0, 1, 3, 1],
       [1, 1, 2, 0, 1, 0, 1],
       [1, 4, 0, 0, 4, 0, 1],
       [1, 1, 1, 1, 1, 1, 1]]

# [22035,38],
s12 = [[0, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0],
       [1, 1, 1, 1, 1, 0, 0, 0, 1, 1, 1, 1],
       [1, 0, 0, 0, 2, 0, 0, 0, 0, 0, 0, 1],
       [1, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 0, 2, 1, 1, 1, 0, 0, 0, 1],
       [1, 0, 0, 0, 0, 1, 0, 1, 4, 0, 4, 1],
       [1, 1, 1, 1, 1, 1, 0, 1, 1, 1, 1, 1]]

# [26905,28],
s13 = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 4, 0, 0, 0, 0, 0, 2, 0, 1],
       [1, 0, 2, 0, 0, 0, 0, 0, 4, 1],
       [1, 0, 3, 0, 0, 0, 0, 0, 2, 1],
       [1, 0, 0, 0, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 0, 0, 0, 0, 0, 4, 1],
       [1, 1, 1, 1, 1, 1, 1, 1, 1, 1]]

# [41715,53],
s14 = [[0, 0, 1, 0, 0, 0, 0],
       [0, 2, 1, 4, 0, 0, 0],
       [0, 2, 0, 4, 0, 0, 0],
       [3, 2, 1, 1, 1, 0, 0],
       [0, 0, 1, 4, 0, 0, 0]]

# [48695,44],
s15 = [[1, 1, 1, 1, 1, 1, 1],
       [1, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 2, 2, 0, 1],
       [1, 0, 2, 0, 2, 3, 1],
       [1, 4, 4, 1, 1, 1, 1],
       [1, 4, 4, 1, 0, 0, 0],
       [1, 1, 1, 1, 0, 0, 0]]

# [91344,111],
s16 = [[1, 1, 1, 1, 1, 0, 0, 0],
       [1, 0, 0, 0, 1, 0, 0, 0],
       [1, 2, 1, 0, 1, 1, 1, 1],
       [1, 4, 0, 0, 0, 0, 0, 1],
       [1, 0, 0, 5, 0, 5, 0, 1],
       [1, 0, 5, 0, 1, 0, 1, 1],
       [1, 1, 1, 0, 3, 0, 1, 0],
       [0, 0, 1, 1, 1, 1, 1, 0]]

# [3301278,76],
# Warning: This problem is very hard and could be impossible to solve without a good heuristic!
s17 = [[1, 1, 1, 1, 1, 1, 1, 1, 1, 1],
       [1, 3, 0, 0, 1, 0, 0, 0, 4, 1],
       [1, 0, 2, 0, 2, 0, 0, 4, 4, 1],
       [1, 0, 2, 2, 2, 1, 1, 4, 4, 1],
       [1, 0, 0, 0, 0, 1, 1, 4, 4, 1],
       [1, 1, 1, 1, 1, 1, 0, 0, 0, 0]]

# [??,25],
s18 = [[0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],
       [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0],
       [1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 1],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 4, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 1, 0, 2, 0, 0, 0, 4, 1, 0, 0, 0, 0]]

# [??,21],
s19 = [[0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1],
       [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0],
       [0, 0, 0, 0, 0, 0, 3, 0, 0, 0, 2, 0],
       [0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 4],
       [1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 1, 1],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0],
       [0, 0, 0, 1, 0, 2, 0, 4, 1, 0, 0, 0]]


# Utility functions for printing states and moves.
# You do not need to understand any of the functions below this point.


# Helper function of prettyMoves
# Detect the move from state s --> s1
def detectDiff(s, s1):
    row, col = getKeeperPosition(s)
    row1, col1 = getKeeperPosition(s1)
    if (row1 == row + 1):
        return 'Down'
    if (row1 == row - 1):
        return 'Up'
    if (col1 == col + 1):
        return 'Right'
    if (col1 == col - 1):
        return 'Left'
    return 'fail'


# Translates a list of states into a list of moves
def prettyMoves(lists):
    initial = 0
    action = []
    for states in (lists):
        if (initial != 0):
            action.append(detectDiff(previous, states))
        initial = 1
        previous = states
    return action


# Print the content of the square to stdout.
def printsquare(v):
    if (v == blank):
        print(' ', end='')
    if (v == wall):
        print('#', end='')
    if (v == box):
        print('$', end='')
    if (v == keeper):
        print('@', end='')
    if (v == star):
        print('.', end='')
    if (v == boxstar):
        print('*', end='')
    if (v == keeperstar):
        print('+', end='')


# Print a state
def printstate(s):
    row = s.shape[0]
    col = s.shape[1]
    for i in range(row):
        for j in range(col):
            printsquare(s[i, j])
        print('\n')


# Print a list of states with delay.
def printlists(lists):
    for states in (lists):
        printstate(states)
        print('\n')


# if __name__ == "__main__":
#     # test_state = np.array(s4)
#     # successors = next_states(test_state)

#     # print(f"Testing next_states on s1:")
#     # print(f"Found {len(successors)} valid moves.\n")

#     # # Print each successor with direction and raw array
#     # for i, succ in enumerate(successors):
#     #     move = detectDiff(test_state, succ)
#     #     print(f"Successor {i + 1} - Move: {move}")
#     #     print(succ)
#     #     print()
        
#     sokoban(s1, h2)

#     sokoban(s2, h2)

#     sokoban(s3, h2)

#     sokoban(s4, h2)
